<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 5.0.0 (20220707.1540)
 -->
<!-- Pages: 1 -->
<svg width="228pt" height="73pt"
 viewBox="0.00 0.00 228.00 73.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 69)">
<g id="a_graph0"><a xlink:title="ISLaSolver class hierarchy">
<polygon fill="white" stroke="transparent" points="-4,4 -4,-69 224,-69 224,4 -4,4"/>
</a>
</g>
<!-- ISLaSolver -->
<g id="node1" class="node">
<title>ISLaSolver</title>
<g id="a_node1"><a xlink:href="isla.solver.ipynb" xlink:title="class ISLaSolver:&#10;The solver class for ISLa formulas/constraints. Main methods: `solve()` and `evaluate()`.">
<polygon fill="none" stroke="black" points="0,-0.5 0,-64.5 82,-64.5 82,-0.5 0,-0.5"/>
<text text-anchor="start" x="8" y="-50.3" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="14.00" fill="#b03a2e">ISLaSolver</text>
<polyline fill="none" stroke="black" points="0,-41.5 82,-41.5 "/>
<g id="a_node1_0"><a xlink:href="#" xlink:title="ISLaSolver">
<g id="a_node1_1"><a xlink:href="isla.solver.ipynb" xlink:title="__init__(self, grammar: Dict[str, List[str]], formula: Union[isla.language.Formula, str], structural_predicates: Set[isla.language.StructuralPredicate] = {Predicate(after, 2), Predicate(nth, 3), Predicate(before, 2), Predicate(different_position, 2), Predicate(same_position, 2), Predicate(level, 4), Predicate(consecutive, 2), Predicate(direct_child, 2), Predicate(inside, 2)}, semantic_predicates: Set[isla.language.SemanticPredicate] = {SemanticPredicate(count, 3)}, max_number_free_instantiations: int = 10, max_number_smt_instantiations: int = 10, max_number_tree_insertion_results: int = 5, enforce_unique_trees_in_queue: bool = True, precompute_reachability: bool = False, debug: bool = False, cost_computer: Optional[ForwardRef(&#39;CostComputer&#39;)] = None, timeout_seconds: Optional[int] = None, global_fuzzer: bool = False, predicates_unique_in_int_arg: Tuple[isla.language.SemanticPredicate, ...] = (SemanticPredicate(count, 3),), fuzzer_factory: Callable[[Dict[str, List[str]]], isla.fuzzer.GrammarFuzzer] = &lt;function ISLaSolver.&lt;lambda&gt;&gt;, tree_insertion_methods=7):&#10;Constructs a new ISLaSolver object. Passing a grammar and a formula is mandatory.&#10;&#10;:param grammar: The underlying grammar.&#10;:param formula: The formula to solve; either a string or a readily parsed formula.&#10;:param structural_predicates: Structural predicates to use when parsing a formula.&#10;:param semantic_predicates: Semantic predicates to use when parsing a formula.&#10;:param max_number_free_instantiations: Number of times that nonterminals that are not bound by any formula&#10;should be expanded by a coverage&#45;based fuzzer.&#10;:param max_number_smt_instantiations: Number of solutions of SMT formulas that should be produced.&#10;:param max_number_tree_insertion_results: The maximum number of results when solving existential quantifiers&#10;by tree insertion.&#10;:param enforce_unique_trees_in_queue: If true, states with the same tree as an already existing tree in the&#10;queue are discarded, irrespectively of the constraint.&#10;:param precompute_reachability: If true, the distances between all grammar nodes are pre&#45;computed using&#10;Floyd&#45;Warshall&#39;s algorithm. This makes sense if there are many expensive distance queries, e.g., in a big&#10;grammar and a constraint with relatively many universal quantifiers.&#10;:param debug: If true, debug information about the evolution of states is collected, notably in the&#10;field state_tree. The root of the tree is in the field state_tree_root. The field costs stores the computed&#10;cost values for all new nodes.&#10;:param cost_computer: The `CostComputer` class for computing the cost relevant to placing states&#10;in ISLa&#39;s queue.&#10;:param timeout_seconds: Number of seconds after which the solver will terminate.&#10;:param global_fuzzer: If set to True, only one coverage&#45;guided grammar fuzzer object is used to finish&#10;off unconstrained open derivation trees throughout the whole generation time. This may be beneficial for&#10;some targets; e.g., we experienced that CSV works significantly faster. However, the achieved k&#45;path coverage&#10;can be lower with that setting.&#10;:param predicates_unique_in_int_arg: This is needed in certain cases for instantiating universal&#10;integer quantifiers. The supplied predicates should have exactly one integer argument, and hold&#10;for exactly one integer value once all other parameters are fixed.&#10;:param fuzzer_factory: Constructor of the fuzzer to use for instantiating &quot;free&quot; nonterminals.&#10;:param tree_insertion_methods: Combination of methods to use for existential quantifier elimination by&#10;tree insertion. Full selection: `DIRECT_EMBEDDING &amp; SELF_EMBEDDING &amp; CONTEXT_ADDITION`.">
<text text-anchor="start" x="11" y="-30" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">__init__()</text>
</a>
</g>
<g id="a_node1_2"><a xlink:href="isla.solver.ipynb" xlink:title="evaluate(self, inp: isla.derivation_tree.DerivationTree | str) &#45;&gt; isla.three_valued_truth.ThreeValuedTruth:&#10;Evaluates whether the given derivation tree satisfies the constraint passed to the solver.&#10;&#10;:param inp: The input to evaluate, either readily parsed or as a string.&#10;:return: A three&#45;valued truth value.">
<text text-anchor="start" x="11" y="-19" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">evaluate()</text>
</a>
</g>
<g id="a_node1_3"><a xlink:href="isla.solver.ipynb" xlink:title="solve(self) &#45;&gt; Generator[isla.derivation_tree.DerivationTree, NoneType, NoneType]:&#10;Produces solutions to the constraint passed to the solver instance.&#10;Take care to repeatedly call `next(...)` on the *same* generator object (don&#39;t call `solve()` repeatedly).&#10;:return: A generator of solutions.">
<text text-anchor="start" x="11" y="-8" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="10.00">solve()</text>
</a>
</g>
</a>
</g>
</a>
</g>
</g>
<!-- Legend -->
<g id="node2" class="node">
<title>Legend</title>
<text text-anchor="start" x="100" y="-50" font-family="Patua One, Helvetica, sans-serif" font-weight="bold" font-size="10.00" fill="#b03a2e">Legend</text>
<text text-anchor="start" x="100" y="-40" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="107" y="-40" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-weight="bold" font-size="8.00">public_method()</text>
<text text-anchor="start" x="100" y="-30" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="107" y="-30" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-size="8.00">private_method()</text>
<text text-anchor="start" x="100" y="-20" font-family="Patua One, Helvetica, sans-serif" font-size="10.00">• </text>
<text text-anchor="start" x="107" y="-20" font-family="'Fira Mono', 'Source Code Pro', 'Courier', monospace" font-style="italic" font-size="8.00">overloaded_method()</text>
<text text-anchor="start" x="100" y="-10.8" font-family="Helvetica,sans-Serif" font-size="9.00">Hover over names to see doc</text>
</g>
</g>
</svg>
